example_1:
    question: Find the number of trips for route_id '25490' on a typical Friday
    answer: |
        ```python
        # Get friday service_ids
        friday_services = feed.calendar[(feed.calendar['friday'] == 1)]['service_id']

        # Filter trips for route_id '25490' and friday services
        friday_trips = feed.trips[(feed.trips['route_id'] == '25490') & 
                                    (feed.trips['service_id'].isin(friday_services))]

        # Count the trips
        trip_count = friday_trips.shape[0]

        result = {
            'answer': trip_count,
            'additional_info': "This count includes all trips scheduled for fridays according to the calendar, excluding any exceptions in calendar_dates."
        }
        # Note: No plot or map for this example
        ```

example_2:
    question: Calculate the average trip duration for route_id '25490'
    answer: |
        ```python
        # Filter stop_times for route_id '25490'
        route_25490_trips = feed.trips[feed.trips['route_id'] == '25490']['trip_id']
        route_25490_stop_times = feed.stop_times[feed.stop_times['trip_id'].isin(route_25490_trips)]

        # Calculate trip durations
        trip_durations = route_25490_stop_times.groupby('trip_id').agg({
            'arrival_time': lambda x: x.max() - x.min()
        })

        # Calculate average duration
        avg_duration = trip_durations['arrival_time'].mean()

        # Create the plot
        fig = px.histogram(trip_durations.reset_index(), x='arrival_time', 
                            title='Distribution of Trip Durations for Route 25490')

        result = {
            'answer': avg_duration,  # This is a timedelta object
            'additional_info': f"This calculation is based on {len(trip_durations)} trips.",
            'plot': fig  # This is a plotly Figure object
        }
        # Note: The plot shows the distribution of trip durations for route_id '25490'
        ```

example_3:
    question: Calculate the headway for a given route
    answer: |
        ```python
        # Assume the route_id and direction_id we're interested in
        route_id = feed.routes.route_id.sample(n=1).values[0]
        direction_id = feed.trips[feed.trips.route_id == route_id].direction_id.sample(n=1).values[0]

        # Get all trips for the specified route
        route_trips = feed.trips[(feed.trips['route_id'] == route_id) & (feed.trips['direction_id'] == direction_id)]

        if route_trips.empty:
            result =  {"answer": None, "additional_info": f"No trips found for route {route_id}"}


        # Get the first stop for each trip
        first_stops = feed.stop_times[feed.stop_times['trip_id'].isin(route_trips['trip_id']) & 
                                        (feed.stop_times['stop_sequence'] == 1)]
        first_stop_id = first_stops['stop_id'].iloc[0]

        first_stops = first_stops.sort_values('arrival_time')
        first_stops['headway_minutes'] = first_stops['arrival_time'].diff() /60
        first_stops['arrival_hour'] = first_stops['arrival_time']/3600

        # Calculate overall average headway
        overall_avg_headway = first_stops['headway_minutes'].mean()

        # Create a plot
        fig = px.box(first_stops, x='arrival_hour', y='headway_minutes', 
                        title=f'Headways Distribution for Route {route_id} Direction {direction_id} (at First Stop {first_stop_id})',)
        fig.update_layout(
            xaxis_title="Hour of the day",
            yaxis_title="Headway (minutes)",
        )

        result = {
            'answer': overall_avg_headway,
            'additional_info': (f"Average headway calculated for route {route_id} direction {direction_id} at first stop {first_stop_id}"
                                f"Headways vary by service_id: {service_headways}"),
            'plot': fig
        }
        # Note headways might vary for stops along the route, we calculate for the first stop only
        ```

example_4:
    question: Find the longest route in the GTFS feed
    answer: |
        ```python
        # Group shapes by shape_id and calculate total distance for each shape
        shape_distances = feed.shapes.groupby('shape_id').agg({'shape_dist_traveled': 'max'}).reset_index()

        # Merge shape distances with trips to get route_id for each shape
        route_distances = pd.merge(feed.trips[['route_id', 'shape_id']], shape_distances, on='shape_id', how='left')

        # Group by route_id and find the maximum distance for each route
        route_max_distances = route_distances.groupby('route_id').agg({'shape_dist_traveled': 'max'}).reset_index()

        # Get the longest route
        longest_route = route_max_distances.loc[route_max_distances['shape_dist_traveled'].idxmax()]
        longest_route_info = feed.routes[feed.routes['route_id'] == longest_route['route_id']].iloc[0]

        result = {
            'answer': {
                'route_id': longest_route['route_id'],
                'route_name': longest_route_info['route_long_name'],
                'length': longest_route['shape_dist_traveled']
            },
            'additional_info': longest_route_info,
        }
        ```

        This code calculates the longest route and provides detailed information about it, including its ID, name, and length. The `additional_info` field contains all available information about the route from the GTFS feed.

example_5:
    question: Identify the date when a specific route had the fewest trips in the GTFS feed.
    answer: |
        ```python
        # Specify the route_id we're interested in
        route_id = "25491"

        # Get trips for the specified route
        route_trips = feed.trips[feed.trips["route_id"] == route_id]
        valid_services = set(route_trips.service_id)

        # Count trips per service
        service_trip_count = route_trips.groupby("service_id").size()

        # Get date range
        start_date = feed.feed_info["feed_start_date"].iloc[0]
        end_date = feed.feed_info["feed_end_date"].iloc[0]
        date_range = pd.date_range(start=start_date, end=end_date)
        date_range = [date.date() for date in date_range]

        date_trip_count = {}
        for date in date_range:
            day_of_week = date.strftime("%A").lower()
            
            # Get active services for the date
            active_services = set(feed.calendar[
                (feed.calendar["start_date"] <= date) &
                (feed.calendar["end_date"] >= date) &
                (feed.calendar[day_of_week] == 1)
            ].service_id)
            
            # Apply exceptions
            exceptions = feed.calendar_dates[feed.calendar_dates["date"] == date]
            for _, exception in exceptions.iterrows():
                if exception["exception_type"] == 1:
                    active_services.add(exception["service_id"])
                elif exception["exception_type"] == 2:
                    active_services.discard(exception["service_id"])
            
            # Count trips for active services that are valid for this route
            trips = sum(service_trip_count.get(service, 0) 
                        for service in (active_services & valid_services))
            
            date_trip_count[date] = trips

        # Convert the dictionary to a DataFrame for easier analysis
        trip_count_df = pd.DataFrame.from_dict(date_trip_count, orient='index', columns=['trip_count'])
        trip_count_df = trip_count_df[trip_count_df['trip_count'] > 0]  # Exclude dates with no service

        # Find the date with the minimum number of trips
        min_trips_date = trip_count_df['trip_count'].idxmin()
        min_trips_count = trip_count_df.loc[min_trips_date, 'trip_count']

        # Create the plot
        fig = px.line(trip_count_df.reset_index(), x='index', y='trip_count', 
                    title=f'Trip Counts for Route {route_id}')

        result = {
            'answer': {
                'date': min_trips_date,
                'trip_count': min_trips_count
            },
            'additional_info': f"This analysis covered the period from {start_date} to {end_date}. The route analyzed was {route_id}.",
            'plot': fig  # This is a plotly Figure object
        }
        ```

        This code identifies the date with the fewest trips for the specified route, provides the trip count for that date, and creates a line plot showing how the number of trips varies over time. The additional information includes the date range of the analysis and the route ID that was analyzed.

example_6:
    question: Find directions from Orchard Downs to Newmark Civil Engineering Laboratory now
    answer: |
        ```python
        def remove_text_in_braces(text):
            return re.sub(r"\(.*?\)", "", text).strip()


        def format_time_hhmmss(time):
            time = int(time)
            return f"{time // 3600:02d}:{(time % 3600) // 60:02d}:{time % 60:02d}"


        def find_stops(feed, query, city=None, num_stops=3):
            def fuzzy_search(threshold):
                clean_stop_names = feed.stops["stop_name"].apply(remove_text_in_braces)
                clean_query = remove_text_in_braces(query)
                best_matches = process.extract(
                    clean_query, clean_stop_names, scorer=fuzz.ratio, limit=num_stops
                )
                return feed.stops[
                    clean_stop_names.isin(
                        [match[0] for match in best_matches if match[1] >= threshold]
                    )
                ]

            # Try exact matching
            query_words = query.lower().split()
            mask = (
                feed.stops["stop_name"]
                .str.lower()
                .apply(lambda x: all(word in x for word in query_words))
            )
            matched_stops = feed.stops[mask]

            # If exact matching fails, try fuzzy matching
            if matched_stops.empty:
                matched_stops = fuzzy_search(80)  # Try with threshold 80 first

            # If still no matches and city is provided, use geolocation (assuming get_geo_location function exists)
            if matched_stops.empty and city:
                location = get_geo_location(f"{query}, {city}")
                if location:
                    lat, lon = location
                    matched_stops = (
                        feed.stops.apply(
                            lambda row: geodesic(
                                (lat, lon), (row["stop_lat"], row["stop_lon"])
                            ).meters,
                            axis=1,
                        )
                        .nsmallest(num_stops)
                        .index
                    )
                    matched_stops = feed.stops.loc[matched_stops]

            return matched_stops


        def find_route_directions(feed, start_stops, end_stops):
            now = datetime.now()
            current_time_seconds = now.hour * 3600 + now.minute * 60 + now.second
            current_day = now.strftime("%A").lower()

            # Find active services for the current day
            active_services = feed.calendar[
                (feed.calendar["start_date"] <= now.date())
                & (feed.calendar["end_date"] >= now.date())
                & (feed.calendar[current_day] == 1)
            ]["service_id"].tolist()

            # Filter stop_times for the next hour and active services
            future_stop_times = feed.stop_times[
                (feed.stop_times["departure_time"] > current_time_seconds)
                & (feed.stop_times["departure_time"] <= current_time_seconds + 3600)
            ]
            future_stop_times = future_stop_times[
                future_stop_times["trip_id"].isin(
                    feed.trips[feed.trips["service_id"].isin(active_services)]["trip_id"]
                )
            ]

            possible_trips = []
            for start_stop in start_stops.itertuples():
                for end_stop in end_stops.itertuples():
                    trips_serving_start = set(
                        future_stop_times[future_stop_times["stop_id"] == start_stop.stop_id][
                            "trip_id"
                        ]
                    )
                    trips_serving_end = set(
                        future_stop_times[future_stop_times["stop_id"] == end_stop.stop_id][
                            "trip_id"
                        ]
                    )
                    common_trips = trips_serving_start.intersection(trips_serving_end)

                    for trip_id in common_trips:
                        trip = feed.trips[feed.trips["trip_id"] == trip_id].iloc[0]
                        trip_stops = future_stop_times[future_stop_times["trip_id"] == trip_id]
                        start_stop_row = trip_stops[trip_stops["stop_id"] == start_stop.stop_id].iloc[0]
                        end_stop_row = trip_stops[trip_stops["stop_id"] == end_stop.stop_id].iloc[0]
                        
                        if end_stop_row["stop_sequence"] > start_stop_row["stop_sequence"]:
                            start_time = start_stop_row["departure_time"]
                            end_time = end_stop_row["departure_time"]
                            possible_trips.append(
                                {
                                    "trip": trip,
                                    "start_stop": start_stop,
                                    "end_stop": end_stop,
                                    "start_time": format_time_hhmmss(start_time),
                                    "end_time": format_time_hhmmss(end_time),
                                    "travel_time": end_time - start_time,
                                }
                            )

            return possible_trips


        # Main execution
        start_query, end_query = "Orchard Downs", "Newmark Civil Engineering Laboratory"
        city = "Champaign, IL, USA"

        start_stops = find_stops(feed, start_query, city)
        end_stops = find_stops(feed, end_query, city)

        if start_stops.empty or end_stops.empty:
            result = {
                "answer": "Unable to find stops for one or both locations.",
                "additional_info": f"Please check the location names and try again. Searched stops:\n"
                f"Start location stops: {start_stops.to_dict('records')}\n"
                f"End location stops: {end_stops.to_dict('records')}",
            }
        else:
            possible_trips = find_route_directions(feed, start_stops, end_stops)

            if possible_trips:
                # Best trip is the trip the starts asap
                best_trip = min(possible_trips, key=lambda x: x["start_time"])
                route = feed.routes[
                    feed.routes["route_id"] == best_trip["trip"]["route_id"]
                ].iloc[0]
                route_name = (
                    route["route_long_name"]
                    if pd.notna(route["route_long_name"])
                    else route["route_short_name"]
                )

                result = {
                    "answer": [
                        f"Take the {route_name} from {best_trip['start_stop'].stop_name} at {best_trip['start_time']} "
                        f"to {best_trip['end_stop'].stop_name}, arriving at {best_trip['end_time']}."
                    ],
                    "additional_info": f"Best trip ID is {best_trip['trip']['trip_id']}. Travel time is approximately "
                    f"{best_trip['travel_time']/60:.2f} minutes. Walk to {best_trip['start_stop'].stop_name} "
                    f"to start your journey, and from {best_trip['end_stop'].stop_name} to reach your final destination.",
                }
            else:
                result = {
                    "answer": f"No direct route found between the nearest stops to {start_query} and {end_query}.",
                    "additional_info": f"You might need to transfer between routes. Consider using a trip planner for more complex journeys. "
                    f"Searched stops:\nStart location stops: {start_stops.to_dict('records')}\n"
                    f"End location stops: {end_stops.to_dict('records')}",
                }
        ```

example_8:
    question: Find the stop at University and Victor
    answer: |
        ```python
        import re
        def remove_text_in_braces(text):
            return re.sub(r'\(.*?\)', '', text).strip()

        def find_stops(feed, query, city=None, num_stops=3):
            def find_nearest_stops(lat, lon, stops_df, num_stops=3):
                stops_df['distance'] = stops_df.apply(
                    lambda row: geodesic((lat, lon), (row['stop_lat'], row['stop_lon'])).meters,
                    axis=1
                )
                return stops_df.nsmallest(num_stops, 'distance')

            def fuzzy_search(threshold):
                clean_stop_names = feed.stops['stop_name'].apply(remove_text_in_braces)
                clean_query = remove_text_in_braces(query)
                best_matches = process.extract(clean_query, clean_stop_names, scorer=fuzz.ratio, limit=num_stops)
                return feed.stops[clean_stop_names.isin([match[0] for match in best_matches if match[1] >= threshold])]

            # Step 1: Try exact matching
            query_words = query.lower().split()
            mask = feed.stops['stop_name'].str.lower().apply(lambda x: all(word in x for word in query_words))
            matched_stops = feed.stops[mask]

            # Step 2: If exact matching fails, try fuzzy matching with threshold 80
            if matched_stops.empty:
                matched_stops = fuzzy_search(80)

            # Step 3: If still no matches and city is provided, use geolocation
            if matched_stops.empty and city:
                location = get_geo_location(f"{query}, {city}")
                if location:
                    lat, lon = location
                    matched_stops = find_nearest_stops(lat, lon, feed.stops, num_stops)

            return matched_stops

        matched_stops = find_stops(feed, "University and Victor", city= "Champaign, IL, USA", num_stops = 2)
        if not matched_stops.empty:
                result = {
                    'answer': f"Found {len(matched_stops)} potential stop(s) near University and Victor",
                    'additional_info': ""
                }
                for i, stop in matched_stops.iterrows():
                    result['additional_info'] += f"\nStop {i}:\n"
                    result['additional_info'] += f"Name: {stop['stop_name']}\n"
                    result['additional_info'] += f"Stop ID: {stop['stop_id']}\n"
                    result['additional_info'] += f"Location: Latitude {stop['stop_lat']}, Longitude {stop['stop_lon']}\n"
                    # In case the we use `get_geo_location` for getting the information
                    if stop.get('distance', None):
                        result['additional_info'] += f"Distance from intersection: {stop.get('distance', 'N/A')} meters\n"
        else:
            result = {
                'answer': "No stops found near University and Victor",
                'additional_info': "Unable to locate any nearby stops for this intersection."
            }
